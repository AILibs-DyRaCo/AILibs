package jaicore.search.algorithms.standard.uncertainty.explorationexploitationsearch;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jaicore.search.algorithms.standard.uncertainty.ISolutionDistanceMetric;
import jaicore.search.structure.core.Node;
import jaicore.search.structure.core.OpenCollection;

public class BasicExplorationCandidateSelector<T, V extends Comparable<V>> implements IExplorationCandidateSelector<T, V> {

	private static final Logger logger = LoggerFactory.getLogger(BasicExplorationCandidateSelector.class);
	
	private double minimumSolutionDistanceForExploration;
	
	public BasicExplorationCandidateSelector(double minimumSolutionDistanceForExploration) {
		this.minimumSolutionDistanceForExploration = minimumSolutionDistanceForExploration;
	}
	
	@Override
	public Node<T, V> selectExplorationCandidate(OpenCollection<Node<T, V>> allCandidates, ISolutionDistanceMetric<T> solutionDistanceMetric) {
		T currentlyBestCandidate = allCandidates.peek().getPoint();
		return allCandidates.stream().max((n1, n2) -> {
			try {
				double solutionDistance1 = solutionDistanceMetric.calculateSolutionDistance(n1.getPoint(), currentlyBestCandidate);
				double solutionDistance2 = solutionDistanceMetric.calculateSolutionDistance(n2.getPoint(), currentlyBestCandidate);
				boolean exploreCandidate1 = solutionDistance1 >= minimumSolutionDistanceForExploration;
				boolean exploreCandidate2 = solutionDistance2 >= minimumSolutionDistanceForExploration;
				if (exploreCandidate1 && exploreCandidate2) {
					Double u1 = (Double)n1.getAnnotation("uncertainty");
					Double u2 = (Double)n2.getAnnotation("uncertainty");
					if (u1 != null && u2 != null) {
						return Double.compare(u1, u2);
					} else {
						return 0;
					}
				} else {
					if (exploreCandidate1) {
						return -1;
					} else if (exploreCandidate2) {
						return 1;
					} else {
						Double u1 = (Double)n1.getAnnotation("uncertainty");
						Double u2 = (Double)n2.getAnnotation("uncertainty");
						if (u1 != null && u2 != null) {
							return Double.compare(u1, u2);
						} else {
							return 0;
						}							
					}
				}
			} catch (Exception e) {
				logger.error(e.getMessage());
			}
			return 0;
		}).orElse(null);
	}

}
