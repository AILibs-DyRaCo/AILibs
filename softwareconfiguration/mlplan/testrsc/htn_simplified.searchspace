#
# Small working subset of
# Knowledge base for Auto-WEKA like classifier construction by HTN planning
#
# For Auto-WEKA see:
# Chris Thornton Frank Hutter Holger H. Hoos Kevin Leyton-Brown
# Auto-WEKA: Combined Selection and Hyperparameter Optimization of Classiï¬�cation Algorithms
#


[NonFunctionalRequirements]

int Price: +


[Constants]

-1:Number
0.000000000001:Number
0.00000000001:Number
0.0000000001:Number
0.000000001:Number
0.00000001:Number
0.0000001:Number
0.000001:Number
0.00001:Number
0.0001:Number
0.001:Number
0.01:Number
0.0:Number
0.1:Number
0.2:Number
0.3:Number
0.4:Number
0.5:Number
0.55:Number
0.6:Number
0.65:Number
0.7:Number
0.75:Number
0.8:Number
0.85:Number
0.9:Number
0.95:Number
0.99:Number
1.0:Number
1.1:Number
1.2:Number
1.3:Number
1.4:Number
1.5:Number
1.8:Number
2.0:Number
2.5:Number
2.6:Number
3.0:Number
3.4:Number
3.5:Number
4.0:Number
4.2:Number
4.5:Number
5.0:Number
0:Number
1:Number
2:Number
3:Number
4:Number
5:Number
6:Number
7:Number
8:Number
9:Number
10:Number
12:Number
13:Number
14:Number
15:Number
16:Number
18:Number
20:Number
25:Number
30:Number
32:Number
40:Number
50:Number
60:Number
62:Number
64:Number
70:Number
75:Number
80:Number
90:Number
100:Number
120:Number
125:Number
128:Number
150:Number
175:Number
200:Number
256:Number
100:Number
125:Number
250:Number
500:Number
512:Number
1000:Number
1024:Number
5000:Number
10000:Number
20000:Number
50000:Number

null:String

-A:String
-B:String
-C:String
-D:String
-E:String
-F:String
-H:String
-I:String
-J:String
-K:String
-L:String
-M:String
-N:String
-O:String
-P:String
-Q:String
-R:String
-S:String
-U:String
-V:String
-W:String
-depth:String
--:String


### BASE CLASSIFIERS ###

noFeaturePreprocessing:String

### BASE CLASSIFIERS ###

weka.classifiers.bayes.BayesNet:String
weka.classifiers.bayes.NaiveBayes:String
weka.classifiers.bayes.NaiveBayesMultinomial:String

weka.classifiers.functions.GaussianProcesses:String
weka.classifiers.functions.LinearRegression:String
weka.classifiers.functions.Logistic:String
weka.classifiers.functions.MultilayerPerceptron:String
weka.classifiers.functions.SGD:String
weka.classifiers.functions.SimpleLinearRegression:String
weka.classifiers.functions.SimpleLogistic:String
weka.classifiers.functions.SMO:String
weka.classifiers.functions.SMOreg:String
weka.classifiers.functions.VotedPerceptron:String

weka.classifiers.functions.LibSVM:String

weka.classifiers.lazy.IBk:String
weka.classifiers.lazy.KStar:String

weka.classifiers.rules.DecisionTable:String
weka.classifiers.rules.JRip:String
weka.classifiers.rules.M5Rules:String
weka.classifiers.rules.OneR:String
weka.classifiers.rules.PART:String
weka.classifiers.rules.ZeroR:String

weka.classifiers.trees.DecisionStump:String
weka.classifiers.trees.J48:String
weka.classifiers.trees.LMT:String
weka.classifiers.trees.M5P:String
weka.classifiers.trees.RandomForest:String
weka.classifiers.trees.RandomTree:String
weka.classifiers.trees.REPTree:String


### BASE CLASSIFIERS PARAMETER ###

# Bayes Net searchAlgorithm: Option -Q
weka.classifiers.bayes.net.search.local.K2:String
weka.classifiers.bayes.net.search.local.HillClimber:String
weka.classifiers.bayes.net.search.local.LAGDHillClimber:String
weka.classifiers.bayes.net.search.local.SimulatedAnnealing:String
weka.classifiers.bayes.net.search.local.TabuSearch:String
weka.classifiers.bayes.net.search.local.TAN:String

# Multilayer Perceptron Hidden Layer Type: Option -H
#a:String
i:String
o:String
t:String

# Gaussian Processes, SMO, SMOreg kernel: Option -K
weka.classifiers.functions.supportVector.NormalizedPolyKernel:String
weka.classifiers.functions.supportVector.PolyKernel:String
weka.classifiers.functions.supportVector.Puk:String
weka.classifiers.functions.supportVector.RBFKernel:String

# SMOreg regOptimizer: Option -I
weka.classifiers.functions.supportVector.RegSMO:String
weka.classifiers.functions.supportVector.RegSMOImproved:String

# KStar missingMode: Option -M
a:String
d:String
m:String
n:String

# Decision Table search: Option -S
weka.attributeSelection.BestFirst:String
weka.attributeSelection.GreedyStepwise:String
weka.attributeSelection.Ranker:String

# Decision Table evaluationMeasure: Option -E
acc:string
rmse:String
mae:String
auc:String


### META CLASSIFIERS ###

weka.classifiers.lazy.LWL:String
weka.classifiers.meta.AdditiveRegression:String
weka.classifiers.meta.AdaBoostM1:String
weka.classifiers.meta.AttributeSelectedClassifier:String
weka.classifiers.meta.Bagging:String
weka.classifiers.meta.ClassificationViaRegression:String
weka.classifiers.meta.LogitBoost:String
weka.classifiers.meta.MultiClassClassifier:String
weka.classifiers.meta.RandomCommittee:String
weka.classifiers.meta.RandomSubSpace:String


#META CLASSIFIERS PARAMETER ###

# Locally Weighted Learning nearestNeighbourSearch: Option -A
weka.core.neighboursearch.LinearNNSearch:String


# Other meta methods (not in AutoWEKA)
# Nested Dichotomy Services
weka.classifiers.meta.nestedDichotomies.ND:String
weka.classifiers.meta.nestedDichotomies.RandomPairND:String
weka.classifiers.meta.nestedDichotomies.ClassBalancedND:String
weka.classifiers.meta.nestedDichotomies.DataNearBalancedND:String
weka.classifiers.meta.nestedDichotomies.FurthestCentroidND:String


### ENSEMBLE CLASSIFIERS ###

weka.classifiers.meta.Vote:String
weka.classifiers.meta.Stacking:String

# Other ensemble methods (not in AutoWEKA)
weka.classifiers.meta.MultiBoostAB:String


### ENSEMBLE CLASSIFIERS PARAMETER ###

# Voting combinationRule: Option -R
AVG:string
PROD:String
MAJ:String
MIN:String
MAX:String


[Types]

Thing;
Image;
JPGImage;Image
BMPImage;Image
GIFImage;Image
FeatureVector;
Number;
Value;
Instances;
Filter;
Classes;
Boolean;
Spam;Boolean
Text;Boolean


[Services]

### Helper Services ###
noop;;;;;(0)

inheritInstanceProp	; x:Instances,y:Instances; ; Instances(x) & assigned(x,y) ; Instances(y);(0)

copyNormalizedInstances;x:Thing,y:Thing;;;Instances(y) & normalized(y);(0)
split;	x:Instances; split:List<Instances>; Instances(x); List<Instances>(split); (0)
retrieveTrain;	s:List<Instances>; train:Instances; List<Instances>(s); Instances(train); (0)
retrieveTest;	s:List<Instances>; test:Instances; List<Instances>(s); Instances(test); (0)

assignTo			; s1:String; s2:String; ; assigned(s1,s2); (0)

getOptionList; 		; o:List<String>; ; List<String>(o); (0)

addOption			; oList:List<String>, o:String,currentMax:String;; List<String>(oList) & !in(oList, o); in(oList, o); (0)
addOptionPair		; oList:List<String>, o:String, v:Value,currentMax:String;; List<String>(oList) & !in(oList, o); in(oList, o) & optVal(oList,o,v); (0)

addSingleParam		; oList:List<String>, p:String; ; List<String>(oList) ; in(oList, p) ; (0)
noaddSingleParam	; oList:List<String>, p:String; ; List<String>(oList) ; notin(oList, p) ; (0)
addValuedParam		; oList:List<String>, p:String, v:Value; ; List<String>(oList) ; in(oList, p) & optVal(oList,p,v); (0)
noaddValuedParam	; oList:List<String>, p:String, v:Value; ; List<String>(oList) ; notin(oList, p) & optVal(oList,p,v); (0)

concatenateWithName	; cn:String, oLocal:List<String>; param:String; List<String>(oLocal); String(param); (0)
concatenate			; oLocal:List<String>; param:String; List<String>(oLocal); String(param); (0)
appendOptions		; l1:List<String>, l2:List<String>; ; List<String>(l1) & List<String>(l2);appended(l1,l2);(0)

compileOptionListToArray; oList:List<String>; oArray:String[]; List<String>(oList); String[](oArray); (0)

# Evaluation
weka.classifiers.evaluation.Evaluation:__construct;test:Instances;e:Evaluation;Instances(test);Evaluation(e);(0)
weka.classifiers.evaluation.Evaluation:crossValidateModel;e:Evaluation,c:Classifier,x:Instances,f:Folds,r:Random;;Evaluation(e) & Classifier(c)& Instances(x) & Random(r) & Folds(f);;(0)
weka.classifiers.evaluation.Evaluation:evaluateModel;e:Evaluation,c:Classifier,x:Instances;;Evaluation(e) & Classifier(c)& Instances(x);;(0)
weka.classifiers.evaluation.Evaluation:pctCorrect;e:Evaluation;q:Double;Evaluation(e);Double(q);(0)


### DATA PREPROCESSING ###
####### weka.filters.Filter:useFilter;x:Instances,p:DataPreprocessor;z:Instances;DataPreprocessor(p) & Instances(x); Instances(z);(0)

weka.filters.unsupervised.attribute.Normalize:__construct;;p:DataPreprocessor;;DataPreprocessor(p);(0)
weka.filters.unsupervised.attribute.Normalize:setInputFormat;p:DataPreprocessor,x:Instances;;DataPreprocessor(p) & Instances(x);normalized(x);(0)
weka.filters.unsupervised.attribute.Standardize:__construct;;p:DataPreprocessor;;DataPreprocessor(p);(0)
weka.filters.unsupervised.attribute.Standardize:setInputFormat;p:DataPreprocessor,x:Instances;;DataPreprocessor(p) & Instances(x);standardized(x);(0)


### FEATURE PREPROCESSING ###

# Generic filter construction and application
weka.attributeSelection.AttributeSelection:__construct;;as;;FeatureSelectionFilter(as);(0)
weka.attributeSelection.AttributeSelection:setEvaluator;as,fe;;FeatureSelectionFilter(as) & FeatureEvaluator(fe);evalSet(as,fe);(0)
weka.attributeSelection.AttributeSelection:setSearch;as,fs;;FeatureSelectionFilter(as) & FeatureSearcher(fs);searchSet(as,fs);(0)


### FEATURE SELECTION SEARCHER ###

weka.attributeSelection.BestFirst:__construct;;s;;FeatureSearcher(s);(0)
weka.attributeSelection.BestFirst:setOptions;s,o;;FeatureSearcher(s) & String[](o);optSet(s);(0)
weka.attributeSelection.GreedyStepwise:__construct;;s;;FeatureSearcher(s);(0)
weka.attributeSelection.GreedyStepwise:setOptions;s,o;;FeatureSearcher(s) & String[](o);optSet(s);(0)
weka.attributeSelection.Ranker:__construct;;s;;FeatureSearcher(s);(0)
weka.attributeSelection.Ranker:setOptions;s,o;;FeatureSearcher(s) & String[](o);optSet(s);(0)


### FEATURE SELECTION EVALUATORS ###

weka.attributeSelection.CfsSubsetEval:__construct;;e;;FeatureEvaluator(e);(0)
weka.attributeSelection.CfsSubsetEval:setOptions;e,o;;FeatureEvaluator(e) & String[](o);optSet(e);(0)
weka.attributeSelection.CorrelationAttributeEval:__construct;;e;;FeatureEvaluator(e);(0)
weka.attributeSelection.CorrelationAttributeEval:setOptions;e,o;;FeatureEvaluator(e) & String[](o);optSet(e);(0)
weka.attributeSelection.GainRatioAttributeEval:__construct;;e;;FeatureEvaluator(e);(0)
weka.attributeSelection.GainRatioAttributeEval:setOptions;e,o;;FeatureEvaluator(e) & String[](o);optSet(e);(0)
weka.attributeSelection.InfoGainAttributeEval:__construct;;e;;FeatureEvaluator(e);(0)
weka.attributeSelection.InfoGainAttributeEval:setOptions;e,o;;FeatureEvaluator(e) & String[](o);optSet(e);(0)
weka.attributeSelection.OneRAttributeEval:__construct;;e;;FeatureEvaluator(e);(0)
weka.attributeSelection.OneRAttributeEval:setOptions;e,o;;FeatureEvaluator(e) & String[](o);optSet(e);(0)
weka.attributeSelection.PrincipalComponents:__construct;;e;;FeatureEvaluator(e);(0)
weka.attributeSelection.PrincipalComponents:setOptions;e,o;;FeatureEvaluator(e) & String[](o);optSet(e);(0)
weka.attributeSelection.ReliefFAttributeEval:__construct;;e;;FeatureEvaluator(e);(0)
weka.attributeSelection.ReliefFAttributeEval:setOptions;e,o;;FeatureEvaluator(e) & String[](o);optSet(e);(0)
weka.attributeSelection.SymmetricalUncertAttributeEval:__construct;;e;;FeatureEvaluator(e);(0)
weka.attributeSelection.SymmetricalUncertAttributeEval:setOptions;e,o;;FeatureEvaluator(e) & String[](o);optSet(e);(0)


### CLASSIFIER INITIALIZATION ###

# Classifier and their configuration methods
# Base Classifier
weka.classifiers.bayes.BayesNet:__construct;;c;;Classifier(c);(0)
weka.classifiers.bayes.BayesNet:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.bayes.NaiveBayes:__construct;;c;;Classifier(c);(0)
weka.classifiers.bayes.NaiveBayes:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.bayes.NaiveBayesMultinomial:__construct;;c;;Classifier(c);(0)
weka.classifiers.bayes.NaiveBayesMultinomial:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.GaussianProcesses:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.GaussianProcesses:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.LinearRegression:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.LinearRegression:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.Logistic:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.Logistic:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.MultilayerPerceptron:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.MultilayerPerceptron:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
####### weka.classifiers.functions.MultilayerPerceptron:setHiddenLayers;c:Classifier,h:String;;Classifier(c) & String(h);optSet(c);(0)
weka.classifiers.functions.SGD:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.SGD:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.LibSVM:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.LibSVM:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.SimpleLinearRegression:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.SimpleLinearRegression:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.SimpleLogistic:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.SimpleLogistic:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.SMO:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.SMO:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.SMOreg:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.SMOreg:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.functions.VotedPerceptron:__construct;;c;;Classifier(c);(0)
weka.classifiers.functions.VotedPerceptron:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.lazy.IBk:__construct;;c;;Classifier(c);(0)
weka.classifiers.lazy.IBk:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.lazy.KStar:__construct;;c;;Classifier(c);(0)
weka.classifiers.lazy.KStar:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.rules.DecisionTable:__construct;;c;;Classifier(c);(0)
weka.classifiers.rules.DecisionTable:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.rules.JRip:__construct;;c;;Classifier(c);(0)
weka.classifiers.rules.JRip:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.rules.M5Rules:__construct;;c;;Classifier(c);(0)
weka.classifiers.rules.M5Rules:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.rules.OneR:__construct;;c;;Classifier(c);(0)
weka.classifiers.rules.OneR:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.rules.PART:__construct;;c;;Classifier(c);(0)
weka.classifiers.rules.PART:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.rules.ZeroR:__construct;;c;;Classifier(c);(0)
weka.classifiers.rules.ZeroR:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.trees.DecisionStump:__construct;;c;;Classifier(c);(0)
weka.classifiers.trees.DecisionStump:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.trees.J48:__construct;;c;;Classifier(c);(0)
weka.classifiers.trees.J48:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.trees.LMT:__construct;;c;;Classifier(c);(0)
weka.classifiers.trees.LMT:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.trees.M5P:__construct;;c;;Classifier(c);(0)
weka.classifiers.trees.M5P:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.trees.RandomForest:__construct;;c;;Classifier(c);(0)
weka.classifiers.trees.RandomForest:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.trees.RandomTree:__construct;;c;;Classifier(c);(0)
weka.classifiers.trees.RandomTree:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)
weka.classifiers.trees.REPTree:__construct;;c;;Classifier(c);(0)
weka.classifiers.trees.REPTree:setOptions;c,o;;Classifier(c) & String[](o);optSet(c);(0)

# Nested Dichotomy Services
weka.classifiers.meta.nestedDichotomies.ND:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.nestedDichotomies.ND:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.nestedDichotomies.RandomPairND:__construct;;c:Classifier;;Classifier(c);(0)
weka.classifiers.meta.nestedDichotomies.RandomPairND:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.nestedDichotomies.ClassBalancedND:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.nestedDichotomies.ClassBalancedND:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.nestedDichotomies.DataNearBalancedND:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.nestedDichotomies.DataNearBalancedND:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.nestedDichotomies.FurthestCentroidND:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.nestedDichotomies.FurthestCentroidND:setOptions;c,o;;Classifier(c) & String[](o);;(0)

# Meta Classifier
weka.classifiers.lazy.LWL:__construct;;c;;Classifier(c);(0)
weka.classifiers.lazy.LWL:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.AdditiveRegression:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.AdditiveRegression:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.AdaBoostM1:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.AdaBoostM1:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.AttributeSelectedClassifier:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.AttributeSelectedClassifier:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.Bagging:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.Bagging:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.ClassificationViaRegression:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.ClassificationViaRegression:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.LogitBoost:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.LogitBoost:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.MultiClassClassifier:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.MultiClassClassifier:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.RandomCommittee:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.RandomCommittee:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.RandomSubSpace:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.RandomSubSpace:setOptions;c,o;;Classifier(c) & String[](o);;(0)

# Ensemble Classifier
weka.classifiers.meta.Vote:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.Vote:setOptions;c,o;;Classifier(c) & String[](o);;(0)
weka.classifiers.meta.Stacking:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.Stacking:setOptions;c,o;;Classifier(c) & String[](o);;(0)

# Other ensemble methods
weka.classifiers.meta.MultiBoostAB:__construct;;c;;Classifier(c);(0)
weka.classifiers.meta.MultiBoostAB:setOptions;c,o;;Classifier(c) & String[](o);;(0)


[Methods]

### Helper Methods ###

# optional parameters
addOptionalParameterNo					; addOptParam(o,p);						o,p; ; noaddSingleParam(o,p)
addOptionalParameterYes					; addOptParam(o,p);						o,p; ; addSingleParam(o,p)
addOptionalValuedParameterNo			; addOptValuedParam(o,p,v);				o,p,v; ; noaddValuedParam(o,p,v)
addOptionalValuedParameterYes			; addOptValuedParam(o,p,v);				o,p,v; ; addValuedParam(o,p,v)
# p | q in {REMOVE_PREV} (p must be present if q is not)
condAddOptionalParameterNo				; condAddOptParam(o,p,q);				o,p,q; in(o,q) ; addOptParam(o,p)
condAddOptionalParameterYes				; condAddOptParam(o,p,q);				o,p,q; notin(o,q) ; addSingleParam(o,p)
condAddOptionalValuedParameterNo		; condAddOptValuedParam(o,p,v,q);		o,p,v,q; in(o,q) ; addOptValuedParam(o,p,v)
condAddOptionalValuedParameterYes		; condAddOptValuedParam(o,p,v,q);		o,p,v,q; notin(o,q) ; addValuedParam(o,p,v)
# p | q in {REMOVED} (p must be present if q is present)
negCondAddOptionalParameterNo			; negCondAddOptParam(o,p,q);			o,p,q; in(o,q) ; addSingleParam(o,p)
negCondAddOptionalParameterYes			; negCondAddOptParam(o,p,q);			o,p,q; notin(o,q) ; addOptParam(o,p)
negCondAddOptionalValuedParameterNo		; negCondAddOptValuedParam(o,p,v,q);	o,p,v,q; in(o,q) ; addValuedParam(o,p,v)
negCondAddOptionalValuedParameterYes	; negCondAddOptValuedParam(o,p,v,q);	o,p,v,q; notin(o,q) ; addOptValuedParam(o,p,v)
# mandatory parameters
addMandatoryParameter					; addMandatParam(o,p);					o,p; ; addSingleParam(o,p)
addMandatoryValuedParameter				; addMandatValuedParam(o,p,v);			o,p,v; ; addValuedParam(o,p,v)


### Main ###

inductionMethod;	induce(x);	x,dn,d,fsn,fs,fen,fe,as,cn,c; ; createDataPreprocessor(dn,d) -> createRawFeaturePreprocessor(fsn,fs,fen,fe,as) -> createClassifier(c) -> createGivenFeaturePreprocessor(fsn,fs,fen,fe,as)
wekaRawClassification;	createRawClassifier(cn,c); cn,c; ; wekaCreateRawClassifier(cn,c)
wekaGivenClassification;	createGivenClassifier(cn,c); cn,c; ; wekaCreateGivenClassifier(cn,c)
wekaClassification;	createClassifier(c); c; ; wekaCreateClassifier(c)


### DATA PREPROCESSORS ###

wekaPreprocessData; createDataPreprocessor(dn,d); dn,d; ; assignTo('noDataPreprocessing',dn)
#wekaNormalize; createDataPreprocessor(dn,d); dn,d; ; weka.filters.unsupervised.attribute.Normalize:__construct(d) -> assignTo('weka.filters.unsupervised.attribute.Normalize',dn)
#wekaStandardize; createDataPreprocessor(dn,d); dn,d; ; weka.filters.unsupervised.attribute.Standardize:__construct(d) -> assignTo('weka.filters.unsupervised.attribute.Standardize',dn)


### FEATURE PREPROCESSORS ###

# No preprocessing
#wekaPreprocessFeatures; createRawFeaturePreprocessor(fsn,fs,fen,fe,as); fsn,fs,fen,fe,as; ; assignTo('noFeaturePreprocessing',fsn)
#wekaPreprocessFeatures; createGivenFeaturePreprocessor(fsn,fs,fen,fe,as); fsn,fs,fen,fe,as; assigned('noFeaturePreprocessing',fsn) ; noop
# Do preprocessing
wekaPreprocessFeatures; createRawFeaturePreprocessor(fsn,fs,fen,fe,as); fsn,fs,fen,fe,as; ; wekaCreateRawFeaturePreprocessor(fsn,fs,fen,fe,as)
wekaPreprocessFeatures; createGivenFeaturePreprocessor(fsn,fs,fen,fe,as); fsn,fs,fen,fe,as; !assigned('noFeaturePreprocessing',fsn) ; wekaCreateGivenFeaturePreprocessor(fsn,fs,fen,fe,as)

# Generic Attribute Selection
wekaRawAttributeSelection	; wekaCreateRawFeaturePreprocessor(fsn,fs,fen,fe,as); fsn,fs,fen,fe,as; ; weka.attributeSelection.AttributeSelection:__construct(as) -> getWekaRawAS(fsn,fs,fen,fe) -> weka.attributeSelection.AttributeSelection:setSearch(as,fs) -> weka.attributeSelection.AttributeSelection:setEvaluator(as,fe)
wekaRawAttributeSelection	; getWekaRawAS(fsn,fs,fen,fe); fsn,fs,fen,fe; ; wekaRawFeatureSubsetSearch(fsn,fs) -> wekaRawFeatureSubsetEvaluation(fen,fe)
wekaRawAttributeSelection	; getWekaRawAS(fsn,fs,fen,fe); fsn,fs,fen,fe; ; wekaRawFeatureRankingSearch(fsn,fs) -> wekaRawFeatureRankingEvaluation(fen,fe)

wekaGivenAttributeSelection	; wekaCreateGivenFeaturePreprocessor(fsn,fs,fen,fe,as); fsn,fs,fen,fe,as; ; getWekaGivenAS(fsn,fs,fen,fe)
wekaGivenAttributeSelection	; getWekaGivenAS(fsn,fs,fen,fe); fsn,fs,fen,fe; ; wekaParametrizeGivenFeatureSubsetSearch(fsn,fs) -> wekaParametrizeGivenFeatureSubsetEvaluation(fen, fe)
wekaGivenAttributeSelection	; getWekaGivenAS(fsn,fs,fen,fe); fsn,fs,fen,fe; ; wekaRawFeatureRankingSearch(fsn,fs) -> wekaParametrizeGivenFeatureRankingEvaluation(fen, fe)

wekaAttributeSelection	; wekaCreateFeaturePreprocessor(fsn,fs,fen,fe,as); fsn,fs,fen,fe,as; ; wekaCreateRawFeaturePreprocessor(fsn,fs,fen,fe,as) -> wekaCreateGivenFeaturePreprocessor(fsn,fs,fen,fe,as)


### FEATURE SELECTION SEARCHER ###

# Best First
#wekaBF;	wekaRawFeatureSubsetSearch(fsn,fs); fsn,fs; ; weka.attributeSelection.BestFirst:__construct(fs) -> assignTo('weka.attributeSelection.BestFirst',fsn)
wekaBF;	wekaParametrizeGivenFeatureSubsetSearch(fsn,fs); fsn,fs,oList,oArray; assigned('weka.attributeSelection.BestFirst',fsn) ; getOptionList(oList) -> getWekaBFConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.BestFirst:setOptions(fs,oArray)
wekaBF;	wekaParametrizeFeatureSubsetSearch(fsn,fs); fsn,fs,oList,oArray; ; weka.attributeSelection.BestFirst:__construct(fs) -> assignTo('weka.attributeSelection.BestFirst',fsn) -> getOptionList(oList) -> getWekaBFConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.BestFirst:setOptions(fs,oArray)
# -D <int> mandatory
wekaBFOptsDirection			; getWekaBFConfig0(o);	o,int; BFDirection(int) ; addMandatValuedParam(o, '-D', int) -> getWekaBFConfig1(o)
# -N <int> mandatory
wekaBFOptsSearchTermination	; getWekaBFConfig1(o);	o,int; BFSearchTermination(int) ; addMandatValuedParam(o, '-N', int) -> getWekaBFConfig2(o)
# -S 1 mandatory (was 0, but 1 makes more sense)
wekaBFOptsLookupCacheSize	; getWekaBFConfig2(o);	o,int; ; addMandatValuedParam(o, '-S', '1')

# Greedy Stepwise
#wekaGS;	wekaRawFeatureSubsetSearch(fsn,fs); fsn,fs; ; weka.attributeSelection.GreedyStepwise:__construct(fs) -> assignTo('weka.attributeSelection.GreedyStepwise',fsn)
wekaGS;	wekaParametrizeGivenFeatureSubsetSearch(fsn,fs); fsn,fs,oList,oArray; assigned('weka.attributeSelection.GreedyStepwise',fsn) ; getOptionList(oList) -> getWekaGSConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.GreedyStepwise:setOptions(fs,oArray)
wekaGS;	wekaParametrizeFeatureSubsetSearch(fsn,fs); fsn,fs,oList,oArray; ; weka.attributeSelection.GreedyStepwise:__construct(fs) -> assignTo('weka.attributeSelection.GreedyStepwise',fsn) -> getOptionList(oList) -> getWekaGSConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.GreedyStepwise:setOptions(fs,oArray)
# -C, -B, -R optional
wekaGSOptsConservForwSel	; getWekaGSConfig0(o);	o,int; ; addOptParam(o, '-C') -> getWekaGSConfig1(o)
wekaGSOptsSearchBackwards	; getWekaGSConfig1(o);	o,int; ; addOptParam(o, '-B') -> getWekaGSConfig2(o)
wekaGSOptsGenerateRanking	; getWekaGSConfig2(o);	o,int; ; addOptParam(o, '-R') -> getWekaGSConfig3(o)
# -N <int> mandatory, only if -R not used
wekaGSOptsSearchTermination	; getWekaGSConfig3(o);	o,int;  notin(o,'-R') & GSNumToSelect(int) ; addMandatValuedParam(o, '-N', int)
# -T <float> mandatory, only if -R used
wekaGSOptsThreshold			; getWekaGSConfig3(o);	o,float;  in(o,'-R') & GSThreshold(float) ; addMandatValuedParam(o, '-T', float)

# Ranker
wekaRank;	wekaRawFeatureRankingSearch(fsn,fs); fsn,fs; ; weka.attributeSelection.Ranker:__construct(fs) -> assignTo('weka.attributeSelection.Ranker',fsn)
wekaRank;	wekaParametrizeGivenFeatureRankingSearch(fsn,fs); fsn,fs,oList,oArray; assigned('weka.attributeSelection.Ranker',fsn) ; getOptionList(oList) -> getWekaRankConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.Ranker:setOptions(fs,oArray)
wekaRank;	wekaParametrizeFeatureRankingSearch(fsn,fs); fsn,fs,oList,oArray; ; weka.attributeSelection.Ranker:__construct(fs) -> assignTo('weka.attributeSelection.Ranker',fsn) -> getOptionList(oList) -> getWekaRankConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.Ranker:setOptions(fs,oArray)
# -T <float> mandatory
wekaRankOptsThreshold			; getWekaRankConfig0(o);	o,float;  RankThreshold(float) ; addMandatValuedParam(o, '-T', float)


### FEATURE SELECTION EVALUATORS ###

# Correlation-based Feature Subset Selection
#wekaCfsSubsetEval;	wekaRawFeatureSubsetEvaluation(fen,fe); fen,fe; ; weka.attributeSelection.CfsSubsetEval:__construct(fe) -> assignTo('weka.attributeSelection.CfsSubsetEval',fen)
wekaCfsSubsetEval;	wekaParametrizeGivenFeatureSubsetEvaluation(fen,fe); fen,fe,oList,oArray; assigned('weka.attributeSelection.CfsSubsetEval',fen) ; getOptionList(oList) -> getWekaCfsSubsetEvalConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.CfsSubsetEval:setOptions(fe,oArray)
wekaCfsSubsetEval;	wekaParametrizeFeatureSubsetEvaluation(fen,fe); fen,fe,oList,oArray; ; weka.attributeSelection.CfsSubsetEval:__construct(fe) -> assignTo('weka.attributeSelection.CfsSubsetEval',fen) -> getOptionList(oList) -> getWekaCfsSubsetEvalConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.CfsSubsetEval:setOptions(fe,oArray)
# -M, -L optional
wekaCfsSubsetEvalOptsMissingSeparate	; getWekaCfsSubsetEvalConfig0(o);	o; ; addOptParam(o, '-M') -> getWekaCfsSubsetEvalConfig1(o)
wekaCfsSubsetEvalOptsLocallyPredictive	; getWekaCfsSubsetEvalConfig1(o);	o; ; addOptParam(o, '-L')

# Correlation Attribute Evaluation
#wekaCorrAttrEval;	wekaRawFeatureRankingEvaluation(fen,fe); fen,fe; ; weka.attributeSelection.CorrelationAttributeEval:__construct(fe) -> assignTo('weka.attributeSelection.CorrelationAttributeEval',fen)
wekaCorrAttrEval;	wekaParametrizeGivenFeatureRankingEvaluation(fen,fe); fen,fe,oList,oArray; assigned('weka.attributeSelection.CorrelationAttributeEval',fen) ; noop
wekaCorrAttrEval;	wekaParametrizeFeatureRankingEvaluation(fen,fe); fen,fe,oList,oArray; ; weka.attributeSelection.CorrelationAttributeEval:__construct(fe) -> assignTo('weka.attributeSelection.CorrelationAttributeEval',fen)
# No parameter

# Gain Ratio Attribute Evaluation
#wekaGainRatioAE;	wekaRawFeatureRankingEvaluation(fen,fe); fen,fe; ; weka.attributeSelection.GainRatioAttributeEval:__construct(fe) -> assignTo('weka.attributeSelection.GainRatioAttributeEval',fen)
wekaGainRatioAE;	wekaParametrizeGivenFeatureRankingEvaluation(fen,fe); fen,fe,oList,oArray; assigned('weka.attributeSelection.GainRatioAttributeEval',fen) ; noop
wekaGainRatioAE;	wekaParametrizeFeatureRankingEvaluation(fen,fe); fen,fe,oList,oArray; ; weka.attributeSelection.GainRatioAttributeEval:__construct(fe) -> assignTo('weka.attributeSelection.GainRatioAttributeEval',fen)
# No parameter

# Info Gain Attribute Evaluation
#wekaInfoGainAE;	wekaRawFeatureRankingEvaluation(fen,fe); fen,fe; ; weka.attributeSelection.InfoGainAttributeEval:__construct(fe) -> assignTo('weka.attributeSelection.InfoGainAttributeEval',fen)
wekaInfoGainAE;	wekaParametrizeGivenFeatureRankingEvaluation(fen,fe); fen,fe,oList,oArray; assigned('weka.attributeSelection.InfoGainAttributeEval',fen) ; getOptionList(oList) -> getWekaInfoGainAEConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.InfoGainAttributeEval:setOptions(fe,oArray)
wekaInfoGainAE;	wekaParametrizeFeatureRankingEvaluation(fen,fe); fen,fe,oList,oArray; ; weka.attributeSelection.InfoGainAttributeEval:__construct(fe) -> assignTo('weka.attributeSelection.InfoGainAttributeEval',fen) -> getOptionList(oList) -> getWekaInfoGainAEConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.InfoGainAttributeEval:setOptions(fe,oArray)
# -M, -B optional
wekaInfoGainAEOptsMissingMerge				; getWekaInfoGainAEConfig0(o);	o; ; addOptParam(o, '-M') -> getWekaInfoGainAEConfig1(o)
wekaInfoGainAEOptsBinarizeNumericAttributes	; getWekaInfoGainAEConfig1(o);	o; ; addOptParam(o, '-B')

# OneR Attribute Evaluation
wekaOneRAE;	wekaRawFeatureRankingEvaluation(fen,fe); fen,fe; ; weka.attributeSelection.OneRAttributeEval:__construct(fe) -> assignTo('weka.attributeSelection.OneRAttributeEval',fen)
wekaOneRAE;	wekaParametrizeGivenFeatureRankingEvaluation(fen,fe); fen,fe,oList,oArray; assigned('weka.attributeSelection.OneRAttributeEval',fen) ; getOptionList(oList) -> getWekaOneRAEConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.OneRAttributeEval:setOptions(fe,oArray)
wekaOneRAE;	wekaParametrizeFeatureRankingEvaluation(fen,fe); fen,fe,oList,oArray; ; weka.attributeSelection.OneRAttributeEval:__construct(fe) -> assignTo('weka.attributeSelection.OneRAttributeEval',fen) -> getOptionList(oList) -> getWekaOneRAEConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.OneRAttributeEval:setOptions(fe,oArray)
# -D optional
wekaOneRAEOptsEvalUsingTrainingData	; getWekaOneRAEConfig0(o);	o; ; addOptParam(o, '-D') -> getWekaOneRAEConfig1(o)
# -F <int> mandatory
wekaOneRAEOptsFolds					; getWekaOneRAEConfig1(o);	o,int; OneRAEFolds(int) ; addMandatValuedParam(o, '-F', int) -> getWekaOneRAEConfig2(o)
# -B <int> mandatory
wekaOneRAEOptsMinimumBucketSize		; getWekaOneRAEConfig2(o);	o,int; OneRAEMinimumBucketSize(int) ; addMandatValuedParam(o, '-B', int) -> getWekaOneRAEConfig3(o)
# -S 1 mandatory
wekaOneRAEOptsSeed					; getWekaOneRAEConfig3(o);	o; ; addMandatValuedParam(o, '-S', '1')

# Principal Component Analysis
#wekaPCA;	wekaRawFeatureRankingEvaluation(fen,fe); fen,fe; ; weka.attributeSelection.PrincipalComponents:__construct(fe) -> assignTo('weka.attributeSelection.PrincipalComponents',fen)
wekaPCA;	wekaParametrizeGivenFeatureRankingEvaluation(fen,fe); fen,fe,oList,oArray; assigned('weka.attributeSelection.PrincipalComponents',fen) ; getOptionList(oList) -> getWekaPCAConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.PrincipalComponents:setOptions(fe,oArray)
wekaPCA;	wekaParametrizeFeatureRankingEvaluation(fen,fe); fen,fe,oList,oArray; ; weka.attributeSelection.PrincipalComponents:__construct(fe) -> assignTo('weka.attributeSelection.PrincipalComponents',fen) -> getOptionList(oList) -> getWekaPCAConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.PrincipalComponents:setOptions(fe,oArray)
# -C, -O optional
#wekaPCAOptsCenterData				; getWekaPCAConfig0(o);	o; ; addOptParam(o, '-C') -> getWekaPCAConfig1(o)
wekaPCAOptsTransformBackToOriginal	; getWekaPCAConfig1(o);	o; ; addOptParam(o, '-O') -> getWekaPCAConfig2(o)
# -R <float> mandatory
wekaPCAOptsVarianceCovered			; getWekaPCAConfig2(o);	o,float; PCAVarianceCovered(float) ; addMandatValuedParam(o, '-R', float) -> getWekaPCAConfig3(o)
# -A <int> mandatory
wekaPCAOptsMaximumAttributeNames	; getWekaPCAConfig3(o);	o; ; addMandatValuedParam(o, '-A', '-1')
wekaPCAOptsMaximumAttributeNames	; getWekaPCAConfig3(o);	o,int; PCAMaximumAttributeNames(int) ; addMandatValuedParam(o, '-A', int)

# ReliefF Attribute Evaluation
#wekaReliefF;	wekaRawFeatureRankingEvaluation(fen,fe); fen,fe; ; weka.attributeSelection.ReliefFAttributeEval:__construct(fe) -> assignTo('weka.attributeSelection.ReliefFAttributeEval',fen)
wekaReliefF;	wekaParametrizeGivenFeatureRankingEvaluation(fen,fe); fen,fe,oList,oArray; assigned('weka.attributeSelection.ReliefFAttributeEval',fen) ; getOptionList(oList) -> getWekaReliefFAEConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.ReliefFAttributeEval:setOptions(fe,oArray)
wekaReliefF;	wekaParametrizeFeatureRankingEvaluation(fen,fe); fen,fe,oList,oArray; ; weka.attributeSelection.ReliefFAttributeEval:__construct(fe) -> assignTo('weka.attributeSelection.ReliefFAttributeEval',fen) -> getOptionList(oList) -> getWekaReliefFAEConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.ReliefFAttributeEval:setOptions(fe,oArray)
# -W optional
wekaReliefFAEOptsWeightByDistance			; getWekaReliefFAEConfig0(o);	o; ; addOptParam(o, '-W') -> getWekaReliefFAEConfig1(o)
# -K <int> mandatory
wekaReliefFAEOptsNumNeighbours	; getWekaReliefFAEConfig1(o);	o,int; ReliefFAENumNeighbours(int) ; addMandatValuedParam(o, '-K', int) -> getWekaReliefFAEConfig2(o)
# -A <int> mandatory, only if -W not used
wekaReliefFOptsSigma1	; getWekaReliefFAEConfig2(o);	o; in(o,'-W') ; noop
wekaReliefFOptsSigma2	; getWekaReliefFAEConfig2(o);	o,int; notin(o,'-W') & ReliefFAESigma(int) ; addMandatValuedParam(o, '-A', int)

# Symmetric Uncertainty Attribute Evaluation
wekaSymmUncertAE;	wekaRawFeatureRankingEvaluation(fen,fe); fen,fe; ; weka.attributeSelection.SymmetricalUncertAttributeEval:__construct(fe) -> assignTo('weka.attributeSelection.SymmetricalUncertAttributeEval',fen)
wekaSymmUncertAE;	wekaParametrizeGivenFeatureRankingEvaluation(fen,fe); fen,fe,oList,oArray; assigned('weka.attributeSelection.SymmetricalUncertAttributeEval',fen) ; getOptionList(oList) -> getWekaSymmUncertAEConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.SymmetricalUncertAttributeEval:setOptions(fe,oArray)
wekaSymmUncertAE;	wekaParametrizeFeatureRankingEvaluation(fen,fe); fen,fe,oList,oArray; ; weka.attributeSelection.SymmetricalUncertAttributeEval:__construct(fe) -> assignTo('weka.attributeSelection.SymmetricalUncertAttributeEval',fen) -> getOptionList(oList) -> getWekaSymmUncertAEConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.attributeSelection.SymmetricalUncertAttributeEval:setOptions(fe,oArray)
# -M optional
wekaSymmUncertAEOptsMissingMerge				; getWekaSymmUncertAEConfig0(o);	o; ; addOptParam(o, '-M')


### CLASSIFIER CONSTRUCTION ###

# Weka General Method (single vs. meta vs. ensemble)
wekaBaseClassifier; 		wekaCreateClassifier(c); c; ; wekaCreateBaseClassifier(c)
#wekaMetaClassifier; 		wekaCreateClassifier(c); c; ; wekaCreateMetaClassifier(c)
#wekaEnsembleClassifier;		wekaCreateClassifier(c); c; ; wekaCreateEnsembleClassifier(c)


### BASE CLASSIFIERS ###

# Bayes Network
#wekaBN;	wekaCreateBaseClassifier(c); c; ; weka.classifiers.bayes.BayesNet:__construct(c)
#wekaNB;	wekaCreateBaseClassifier(c); c; ;	weka.classifiers.bayes.NaiveBayes:__construct(c)
#wekaNBMN;	wekaCreateBaseClassifier(c); c; ;	weka.classifiers.bayes.NaiveBayesMultinomial:__construct(c)
#wekaGP;	wekaCreateBaseClassifier(c); c; ;	weka.classifiers.functions.GaussianProcesses:__construct(c)
#wekaLinearR;	wekaCreateBaseClassifier(c); c; ;	weka.classifiers.functions.LinearRegression:__construct(c)
#wekaNN;	wekaCreateBaseClassifier(c); c; ;	weka.classifiers.functions.MultilayerPerceptron:__construct(c)
#wekaSGDs;	wekaCreateBaseClassifier(c); c; ; weka.classifiers.functions.SGD:__construct(c)
#wekaSimpleLinearReg; wekaCreateBaseClassifier(c); c,oList,oArray; ;	weka.classifiers.functions.SimpleLinearRegression:__construct(c)
#wekaSimpleLogisticReg;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.functions.SimpleLogistic:__construct(c)
#wekaSMO;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.functions.SMO:__construct(c)
#wekaSMOreg;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.functions.SMOreg:__construct(c)
#wekaVotedPerceptrons;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.functions.VotedPerceptron:__construct(c)
#wekaKNN;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.lazy.IBk:__construct(c)
#wekaKStar;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.lazy.KStar:__construct(c)
#wekaDecTable;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.rules.DecisionTable:__construct(c)
#wekaRipper;	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.rules.JRip:__construct(c)
#wekaM5Rules; wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.rules.M5Rules:__construct(c)
#wekaOneR; wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.rules.OneR:__construct(c)
#wekaPART; wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.rules.PART:__construct(c)
#wekaZeroR; wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.rules.ZeroR:__construct(c)
#wekaDecisionStump; wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.trees.DecisionStump:__construct(c)
wekaDT; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.trees.J48:__construct(c)
#wekaLMT; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.trees.LMT:__construct(c)
#wekaM5P; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.trees.M5P:__construct(c)
#wekaRF; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.trees.RandomForest:__construct(c)

# Random Tree
#wekaRT; 	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.trees.RandomTree:__construct(c) -> assignTo('weka.classifiers.trees.RandomTree',cn)
#wekaRT; 	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.trees.RandomTree',cn) ; weka.classifiers.trees.RandomTree:__construct(c) -> getOptionList(oList) -> getWekaRTConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.RandomTree:setOptions(c,oArray)
wekaRT; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.trees.RandomTree:__construct(c) -> getOptionList(oList) -> getWekaRTConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.RandomTree:setOptions(c,oArray)
wekaRT; 	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.trees.RandomTree',cn) -> getWekaRTConfig0(oList)
wekaRT; 	wekaSelectBaseClassifier(cn); cn; ; assignTo('weka.classifiers.trees.RandomTree',cn)
wekaRT; 	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.trees.RandomTree',cn) ; getWekaRTConfig0(oList)
# -U optional
wekaRTOptsAllowUnclass	; getWekaRTConfig0(o);	o; ; addOptParam(o, '-U') -> getWekaRTConfig1(o)
# -K <int> mandatory, value 0 for unused
wekaRTOptsKValue		; getWekaRTConfig1(o);	o; ; addMandatValuedParam(o, '-K', '0') -> getWekaRTConfig2(o)
wekaRTOptsKValue		; getWekaRTConfig1(o);	o,int; RTKValue(int) ; addMandatValuedParam(o, '-K', int) -> getWekaRTConfig2(o)
# -M <int> mandatory
wekaRTOptsMinNum		; getWekaRTConfig2(o);	o,int; RTMinNum(int) ; addMandatValuedParam(o, '-M', int) -> getWekaRTConfig3(o)
# -N <int> mandatory, value 0 for unused
wekaRTOptsNumFolds	; getWekaRTConfig3(o);	o; ; addMandatValuedParam(o, '-N', '0') -> getWekaRTConfig4(o)
wekaRTOptsNumFolds	; getWekaRTConfig3(o);	o,int; RTNumFolds(int) ; addMandatValuedParam(o, '-N', int) -> getWekaRTConfig4(o)
# -depth <int> mandatory, value 0 for unused
wekaRTOptsMaxDepth	; getWekaRTConfig4(o);	o; ; addMandatValuedParam(o, '-depth', '0')
wekaRTOptsMaxDepth	; getWekaRTConfig4(o);	o,int; RTMaxDepth(int) ; addMandatValuedParam(o, '-depth', int)

# REP Tree
#wekaREP; 	wekaCreateRawBaseClassifier(cn,c); cn,c; ; weka.classifiers.trees.REPTree:__construct(c) -> assignTo('weka.classifiers.trees.REPTree',cn)
#wekaREP; 	wekaCreateGivenBaseClassifier(cn,c); cn,c,oList,oArray; assigned('weka.classifiers.trees.REPTree',cn) ; weka.classifiers.trees.REPTree:__construct(c) -> getOptionList(oList) -> getWekaREPConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.REPTree:setOptions(c,oArray)
wekaREP; 	wekaCreateBaseClassifier(c); c,oList,oArray; ; weka.classifiers.trees.REPTree:__construct(c) -> getOptionList(oList) -> getWekaREPConfig0(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.trees.REPTree:setOptions(c,oArray)
wekaREP; 	wekaParametrizeBaseClassifier(cn,oList); cn,oList; ; assignTo('weka.classifiers.trees.REPTree',cn) -> getWekaREPConfig0(oList)
wekaREP; 	wekaSelectBaseClassifier(cn); cn; ; assignTo('weka.classifiers.trees.REPTree',cn)
wekaREP; 	wekaParametrizeGivenBaseClassifier(cn,oList); cn,oList; assigned('weka.classifiers.trees.REPTree',cn) ; getWekaREPConfig0(oList)
# -P optional
wekaREPOptsPruning			; getWekaREPConfig0(o);	o; ; addOptParam(o, '-P') -> getWekaREPConfig1(o)
# -L <int> mandatory, value -1 for unused
wekaREPOptsMaxDepth		; getWekaREPConfig1(o);	o; ; addMandatValuedParam(o, '-L', '-1') -> getWekaREPConfig2(o)
wekaREPOptsMaxDepth		; getWekaREPConfig1(o);	o,int; REPMaxDepth(int) ; addMandatValuedParam(o, '-L', int) -> getWekaREPConfig2(o)
# -M <int>, -V <float> mandatory
wekaREPOptsMinNum		; getWekaREPConfig2(o);	o,int; REPMinNum(int) ; addMandatValuedParam(o, '-M', int) -> getWekaREPConfig3(o)
wekaREPOptsMinVariance	; getWekaREPConfig3(o);	o,float; REPMinVariance(float) ; addMandatValuedParam(o, '-V', float)


# Nested Dichotomies
#wekaNDs;	wekaCreateBaseClassifier(c); c; ; wekaCreateNDClassifier(c)
rpnd;	wekaCreateNDClassifier(c);	c,oList,oArray; ;	weka.classifiers.meta.nestedDichotomies.RandomPairND:__construct(c) -> getOptionList(oList) -> getWekaNDConfig(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.nestedDichotomies.RandomPairND:setOptions(c,oArray)
cbnd;	wekaCreateNDClassifier(c);	c,oList,oArray; ;	weka.classifiers.meta.nestedDichotomies.ClassBalancedND:__construct(c) -> getOptionList(oList) -> getWekaNDConfig(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.nestedDichotomies.ClassBalancedND:setOptions(c,oArray)
dnbnd;	wekaCreateNDClassifier(c);	c,oList,oArray; ;	weka.classifiers.meta.nestedDichotomies.DataNearBalancedND:__construct(c) -> getOptionList(oList) -> getWekaNDConfig(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.nestedDichotomies.DataNearBalancedND:setOptions(c,oArray)
fcnd;	wekaCreateNDClassifier(c);	c,oList,oArray; ;	weka.classifiers.meta.nestedDichotomies.FurthestCentroidND:__construct(c) -> getOptionList(oList) -> getWekaNDConfig(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.nestedDichotomies.FurthestCentroidND:setOptions(c,oArray)
nd;		wekaCreateNDClassifier(c);	c,oList,oArray; ;	weka.classifiers.meta.nestedDichotomies.ND:__construct(c) -> getOptionList(oList) -> getWekaNDConfig(oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.nestedDichotomies.ND:setOptions(c,oArray)
wekaNDOptsClose				; getWekaNDConfig(o);	o; ; noop
wekaNDOptsSetBaseLearner	; getWekaNDConfig(o);	o; ; addWekaBaseLearner(o) -> getWekaNDConfig(o)


### META CLASSIFIERS ###

# Parametrization of selected base classifier:
wekaMetaBaseClassifier			; getWekaGivenBaseConfig(cnLocal,o);	o,cnLocal,oLocal; ; getOptionList(oLocal) -> wekaParametrizeGivenBaseClassifier(cnLocal, oLocal) -> addMandatValuedParam(o, '-W', cnLocal) -> addMandatParam(o, '--') -> appendOptions(o, oLocal)
#wekaMetaBaseClassifier			; getWekaGivenBaseConfig(cnLocal,o);	o,cnLocal,oLocal; ; getOptionList(oLocal) -> addMandatValuedParam(o, '-W', cnLocal) -> addMandatParam(o, '--') -> appendOptions(o, oLocal)

# Locally Weighted Learning
#wekaLWL;	wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; weka.classifiers.lazy.LWL:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaLWLConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.lazy.LWL:setOptions(c,oArray)
# -A <class> mandatory
wekaLWLOptsNearestNeighbourSearch	; getWekaLWLConfig0(o);	o,name,oLocal,param; LWLNearestNeighbourSearch(name) ; getOptionList(oLocal) -> addMandatParam(oLocal,name) -> concatenate(oLocal,param) -> addMandatValuedParam(o, '-A', param) -> getWekaLWLConfig1(o)
# -K <int> optional
wekaLWLOptsKNN						; getWekaLWLConfig1(o);	o,int; LWLKNN(int) ; addOptValuedParam(o, '-K', int) -> getWekaLWLConfig2(o)
# -U <int> optional, -K or -U has to be used
wekaLWLOptsWeighingKernel			; getWekaLWLConfig2(o);	o,int; notin(o,'-K') & LWLWeighingKernel(int) ; addMandatValuedParam(o, '-U', int)
wekaLWLOptsWeighingKernel			; getWekaLWLConfig2(o);	o,int; in(o,'-K') & LWLWeighingKernel(int) ; addOptValuedParam(o, '-U', int)
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# AdaBoost
wekaAdaBoost;	wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; weka.classifiers.meta.AdaBoostM1:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaAdaBoostConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.AdaBoostM1:setOptions(c,oArray)
# -Q optional
wekaAdaBoostOptsUseResampling	; getWekaAdaBoostConfig0(o);	o; ; addOptParam(o, '-Q') -> getWekaAdaBoostConfig1(o)
# -I <int> mandatory
wekaAdaBoostOptsNumIterations	; getWekaAdaBoostConfig1(o);	o,int; AdaBoostNumIterations(int) ; addMandatValuedParam(o, '-I', int) -> getWekaAdaBoostConfig2(o)
# -P <int> mandatory, value 100 for unused
wekaAdaBoostOptsWeightThreshold	; getWekaAdaBoostConfig2(o);	o; ; addMandatValuedParam(o, '-P', '100') -> getWekaAdaBoostConfig3(o)
wekaAdaBoostOptsWeightThreshold	; getWekaAdaBoostConfig2(o);	o,int; AdaBoostWeightThreshold(int) ; addMandatValuedParam(o, '-P', int) -> getWekaAdaBoostConfig3(o)
# -S 1  mandatory
wekaAdaBoostOptsSeed			; getWekaAdaBoostConfig3(o);	o; ; addMandatValuedParam(o, '-S', '1')
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# MultiBoost
wekaMultiBoost; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; weka.classifiers.meta.MultiBoostAB:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.MultiBoostAB:setOptions(c,oArray)
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# Additive Regression
wekaAddReg; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; weka.classifiers.meta.AdditiveRegression:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaAddRegConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.AdditiveRegression:setOptions(c,oArray)
# -I <int>  mandatory
wekaAddRegOptsNumIterations	; getWekaAddRegConfig0(o);	o,int; AddRegNumIterations(int) ; addMandatValuedParam(o, '-I', int) -> getWekaAddRegConfig1(o)
# -S <float> mandatory, value 1 for unused
wekaAddRegOptsShrinkage	; getWekaAddRegConfig1(o);	o;  ; addMandatValuedParam(o, '-S', '1')
wekaAddRegOptsShrinkage	; getWekaAddRegConfig1(o);	o,float; AddRegShrinkage(float) ; addMandatValuedParam(o, '-S', float)
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# Attribute Selected
wekaAttributeSelected; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; weka.classifiers.meta.AttributeSelectedClassifier:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaAttributeSelectedConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.AttributeSelectedClassifier:setOptions(c,oArray)
# -S <class>, -E <class>  mandatory
wekaAddRegOptsSearchAndEval	; getWekaAttributeSelectedConfig0(o);	o,oLocal; ; getOptionList(oLocal) -> getWekaASConfig0(oLocal) -> appendOptions(o, oLocal)
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# Bagging
wekaBagging;	wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; weka.classifiers.meta.Bagging:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaBaggingConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.Bagging:setOptions(c,oArray)
# -O optional
wekaBaggingOptsCalcOutOfBag		; getWekaBaggingConfig0(o);	o; ; addOptParam(o, '-O') -> getWekaBaggingConfig1(o)
# -I <int> mandatory
wekaBaggingOptsNumIterations	; getWekaBaggingConfig1(o);	o,int; BaggingNumIterations(int) ; addMandatValuedParam(o, '-I', int) -> getWekaBaggingConfig2(o)
# -P <int> mandatory
wekaBaggingOptsBagSizePercent	; getWekaBaggingConfig2(o);	o; in(o,'-O') ; addMandatValuedParam(o, '-P', '100') -> getWekaBaggingConfig3(o)
wekaBaggingOptsBagSizePercent	; getWekaBaggingConfig2(o);	o,int; notin(o,'-O') & BaggingBagSizePercent(int) ; addMandatValuedParam(o, '-P', int) -> getWekaBaggingConfig3(o)
# -S 1  mandatory
wekaBaggingOptsSeed				; getWekaBaggingConfig3(o);	o; ; addMandatValuedParam(o, '-S', '1')
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# Classification via Regression
wekaClassificationViaRegression; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; weka.classifiers.meta.ClassificationViaRegression:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.ClassificationViaRegression:setOptions(c,oArray)
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# Logit Boost
wekaLogitBoost; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; weka.classifiers.meta.LogitBoost:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaLogitBoostConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.LogitBoost:setOptions(c,oArray)
# -Q optional
wekaLogitBoostOptsUseResampling			; getWekaLogitBoostConfig0(o);	o; ; addOptParam(o, '-Q') -> getWekaLogitBoostConfig1(o)
# -I <int> mandatory
wekaLogitBoostOptsNumIterations			; getWekaLogitBoostConfig1(o);	o,int; LogitBoostNumIterations(int) ; addMandatValuedParam(o, '-I', int) -> getWekaLogitBoostConfig2(o)
# -H <float> mandatory, value 1 for unused
wekaLogitBoostOptsShrinkage				; getWekaLogitBoostConfig2(o);	o;  ; addMandatValuedParam(o, '-H', '1') -> getWekaLogitBoostConfig5(o)
wekaLogitBoostOptsShrinkage				; getWekaLogitBoostConfig2(o);	o,float; LogitBoostShrinkage(float) ; addMandatValuedParam(o, '-H', float) -> getWekaLogitBoostConfig5(o)
# -R <int> mandatory: NOT AVAILABLE IN WEKA 3.8, THEREFORE SKIPPED!!
wekaLogitBoostOptsNumRuns				; getWekaLogitBoostConfig3(o);	o,int; LogitBoostNumRuns(int) ; addMandatValuedParam(o, '-R', int) -> getWekaLogitBoostConfig4(o)
# -F <int> mandatory, value 0 for unused: NOT AVAILABLE IN WEKA 3.8, THEREFORE SKIPPED!!
wekaLogitBoostOptsNumFolds				; getWekaLogitBoostConfig4(o);	o;  ; addMandatValuedParam(o, '-F', '0') -> getWekaLogitBoostConfig5(o)
wekaLogitBoostOptsNumFolds				; getWekaLogitBoostConfig4(o);	o,int; LogitBoostNumFolds(int) ; addMandatValuedParam(o, '-F', int) -> getWekaLogitBoostConfig5(o)
# -P <int> mandatory, value 100 for unused
wekaLogitBoostOptsWeightThreshold		; getWekaLogitBoostConfig5(o);	o; in(o,'-Q') ; noop -> getWekaLogitBoostConfig6(o)
wekaLogitBoostOptsWeightThreshold		; getWekaLogitBoostConfig5(o);	o,int; notin(o,'-Q') & LogitBoostWeightThreshold(int) ; addMandatValuedParam(o, '-P', int) -> getWekaLogitBoostConfig6(o)
# -L 1e50  mandatory
wekaLogitBoostOptsLikelihoodThreshold 	; getWekaLogitBoostConfig6(o);	o; ; addMandatValuedParam(o, '-L', '1e50') -> getWekaLogitBoostConfig7(o)
# -S 1  mandatory
wekaLogitBoostOptsSeed					; getWekaLogitBoostConfig7(o);	o; ; addMandatValuedParam(o, '-S', '1')
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# MultiClass Classifier
wekaMCC; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; weka.classifiers.meta.MultiClassClassifier:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaMCCConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.MultiClassClassifier:setOptions(c,oArray)
# -P optional
wekaMCCOptsUsePairwiseCoupling	; getWekaMCCConfig0(o);	o; ; addOptParam(o, '-P') -> getWekaMCCConfig1(o)
# -M <type> mandatory
wekaMCCOptsMethod				; getWekaMCCConfig1(o);	o,type; MCCMethod(type) ; addMandatValuedParam(o, '-M', type) -> getWekaMCCConfig2(o)
# -R <float> mandatory
wekaMCCOptsRandomWidthFactor	; getWekaMCCConfig2(o);	o,float; MCCRandomWidthFactor(float) ; addMandatValuedParam(o, '-R', float) -> getWekaMCCConfig3(o)
# -S 1  mandatory
wekaMCCOptsSeed					; getWekaMCCConfig3(o);	o; ; addMandatValuedParam(o, '-S', '1')
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# Random Comittee
wekaRandomCommittee; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; weka.classifiers.meta.RandomCommittee:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaRandomComitteeConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.RandomCommittee:setOptions(c,oArray)
# -I <int>, -S 1  mandatory
wekaRandomComitteeOptsNumIterations		; getWekaRandomComitteeConfig0(o);	o,int; RandomComitteeNumIterations(int) ; addMandatValuedParam(o, '-I', int) -> getWekaRandomComitteeConfig1(o)
wekaRandomComitteeOptsSeed				; getWekaRandomComitteeConfig1(o);	o; ; addMandatValuedParam(o, '-S', '1')
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section

# Random Subspace
wekaRandomSubspace; wekaCreateMetaClassifier(c); c,oList,cnLocal,oArray; ; weka.classifiers.meta.RandomSubSpace:__construct(c) -> wekaSelectBaseClassifier(cnLocal) -> getOptionList(oList) -> getWekaRandomSubspaceConfig0(oList) -> getWekaGivenBaseConfig(cnLocal,oList) -> compileOptionListToArray(oList,oArray) -> weka.classifiers.meta.RandomSubSpace:setOptions(c,oArray)
# -I <int> mandatory
wekaRandomSubspaceOptsNumIterations		; getWekaRandomSubspaceConfig0(o);	o,int; RandomSubspaceNumIterations(int) ; addMandatValuedParam(o, '-I', int) -> getWekaRandomSubspaceConfig1(o)
# -P <float> mandatory
wekaRandomSubspaceOptsSubSpaceSize		; getWekaRandomSubspaceConfig1(o);	o,float; RandomSubspaceSubSpaceSizePercent(float) ; addMandatValuedParam(o, '-P', float) -> getWekaRandomSubspaceConfig2(o)
# -S 1  mandatory
wekaRandomSubspaceOptsSeed				; getWekaRandomSubspaceConfig2(o);	o; ; addMandatValuedParam(o, '-S', '1')
# -W <base> mandatory: see global method at beginning of META CLASSIFIERS section



[Rules]
# not necessary in the simplified model


[Queries]

q1;x:Instances;;Instances(x);induce(x);(1000)

